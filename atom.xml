<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>非常大人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-23T10:45:18.513Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>VeryBigMan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WKWebView实现浏览历史恢复</title>
    <link href="http://yoursite.com/2019/01/16/Session-restoration/"/>
    <id>http://yoursite.com/2019/01/16/Session-restoration/</id>
    <published>2019-01-16T00:24:53.000Z</published>
    <updated>2019-01-23T10:45:18.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们发现，使用<code>WKWebView</code>做套壳浏览器，有个很严重的问题，浏览历史不同持久化。</p><h3 id="什么是浏览历史？"><a href="#什么是浏览历史？" class="headerlink" title="什么是浏览历史？"></a>什么是浏览历史？</h3><p><code>WKWebView</code>有个属性叫作<a href="https://developer.apple.com/documentation/webkit/wkwebview/1414977-backforwardlist" target="_blank" rel="noopener">backForwardList</a> (注意是get-only的)<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backForwardList: <span class="type">WKBackForwardList</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>A WKBackForwardList object maintains a list of visited pages used to go back and forward to the most recent page.</p></blockquote><p>也就是说，我们在浏览器里看到的前进/后退按钮，其实就可以由它控制。<a href="https://developer.apple.com/documentation/webkit/wkbackforwardlist/1516698-backlist" target="_blank" rel="noopener">backList</a>表示所有可以后退到的item，<a href="https://developer.apple.com/documentation/webkit/wkbackforwardlist/1516701-forwardlist" target="_blank" rel="noopener">forwardList</a>表示所有可以前进到的item，其中的每个item是<a href="https://developer.apple.com/documentation/webkit/wkbackforwardlistitem" target="_blank" rel="noopener">WKBackForwardListItem</a>的实例，包含<code>url</code>等信息</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backList: [<span class="type">WKBackForwardListItem</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> forwardList: [<span class="type">WKBackForwardListItem</span>] &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>同时，<code>WKWebView</code>暴露了下面的api允许自身在浏览历史中跳转。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Navigates to the back item in the back-forward list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goBack</span><span class="params">()</span></span> -&gt; <span class="type">WKNavigation</span>?</span><br><span class="line"><span class="comment">// Navigates to the forward item in the back-forward list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goForward</span><span class="params">()</span></span> -&gt; <span class="type">WKNavigation</span>?</span><br><span class="line"><span class="comment">// Navigates to an item from the back-forward list and sets it as the current item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go</span><span class="params">(to: WKBackForwardListItem)</span></span> -&gt; <span class="type">WKNavigation</span>?</span><br></pre></td></tr></table></figure></p><h3 id="持久化问题"><a href="#持久化问题" class="headerlink" title="持久化问题"></a>持久化问题</h3><p>浏览器有一个很常见的必备需求 – 保存浏览历史。比如用户访问了A, B, C三个网站，并且退出App的时候处于B网站。那么下次冷启动App的时候，用户自然而然会expect进入B的页面，并且可以后退/前进到A/C。</p><p>然而我们发现，<code>WKWebView</code>本身并没有这样的方法，每次app重新启动初始化<code>WKWebView</code>的时候，<code>backForwardList</code>是全新的，这意味着在用户看来，之前的浏览历史全部消失了！</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>最直观的想法是希望<code>WKWebView</code>本身暴露这样一个功能（然而并没有）</li><li>那么退而求其次我们可以记录用户的访问记录，在app启动的时候构建我们自己的<code>backForwardList</code>，然后assign给<code>WKWebView</code>（很遗憾前面我们提到了<code>backForwardList</code>是get only的，我们无法这样实现）</li><li>再退一步，虽然<code>backForwardList</code>本身是get only的，但是我们可以利用<code>WKWebView</code>暴露的<a href="https://developer.apple.com/documentation/webkit/wkwebview/1414954-load" target="_blank" rel="noopener"><code>load</code></a>接口来模拟实现</li></ol><p>我们来简单实现一下方法3, 这是我们的sample app，有前进/后退两个按钮和一个WebView。</p><img src="/2019/01/16/Session-restoration/sample.png"><p>Persist:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> currentItem = <span class="keyword">self</span>.webView.backForwardList.currentItem <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> filePath = <span class="keyword">self</span>.backforwardHistoryFilePath <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> urls = (<span class="keyword">self</span>.webView.backForwardList.backList + [currentItem] + <span class="keyword">self</span>.webView.backForwardList.forwardList).compactMap &#123; $<span class="number">0</span>.url &#125;</span><br><span class="line"><span class="keyword">let</span> currentIndexButLast = <span class="keyword">self</span>.webView.backForwardList.forwardList.<span class="built_in">count</span></span><br><span class="line"><span class="keyword">let</span> backforwardHistory = <span class="type">BackforwardHistory</span>(urls: urls, currentIndexButLast: <span class="type">Int32</span>(currentIndexButLast))</span><br><span class="line"><span class="type">NSKeyedArchiver</span>.archiveRootObject(backforwardHistory, toFile: filePath)</span><br></pre></td></tr></table></figure></p><p>Restore:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> filePath = <span class="keyword">self</span>.backforwardHistoryFilePath, <span class="keyword">let</span> backforwardHistory = <span class="type">NSKeyedUnarchiver</span>.unarchiveObject(withFile: filePath) <span class="keyword">as</span>? <span class="type">BackforwardHistory</span> &#123;</span><br><span class="line">    backforwardHistory.urls.forEach &#123; url <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.webView.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;backforwardHistory.currentIndexButLast &#123;</span><br><span class="line">        <span class="keyword">self</span>.webView.goBack()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路很简单，</p><ol><li>需要保存浏览历史的时候，拿到<code>WKWebView</code>的<code>backList, currentItem, forwardList</code>来保存<code>url</code>，通过<code>forwardList.count</code>来计算当前页面的index，然后通过<code>NSKeyedArchiver</code>（我们先不考虑performance问题）来做持久化</li><li>需要恢复浏览历史的时候，通过<code>NSKeyedUnarchiver</code>反序列化文件，然后依次加载url，同时结合<code>currentIndexButLast</code>和<code>goBack</code>来实现跳转到指定页面</li></ol><p>通过上面的实现，我们发现当访问了A-&gt;B-&gt;C重启app之后，webview可以恢复历史并且显示C页面，但是却出现了无法后退到B的问题。原因是</p><ul><li>调用<code>WKWebView</code>的<code>load</code>之后，页面加入到<code>backForwardList</code>是需要时间的；官方没有介绍具体的时机，推测大概是在<a href="https://developer.apple.com/documentation/webkit/wknavigationdelegate/1455629-webview" target="_blank" rel="noopener"><code>didFinish</code></a>左右</li><li>上面的code里我们从文件中取出所有的<code>url</code>并连续调用<code>webview.load</code>，这导致前面的页面还没有加入到<code>backForwardList</code>之中我们就跳转到了其他页面，于是最后的结果就是<code>WKWebView</code>的<code>backForwardList</code>中只有最后一个<code>url</code></li><li>因此在点击后退按钮调用<code>goBack()</code>的时候，<code>backForwardList</code>中没有足够的item，无法后退</li></ul><p>一种可能的解决思路是等前一个页面加载完成之后，我们再加载第二个页面，但这样做一是用户体验会差太多，二是不够可靠因为无法确切的知道页面加入到<code>backForwardList</code>的时机。</p><h2 id="如何优雅的解决这个问题呢？"><a href="#如何优雅的解决这个问题呢？" class="headerlink" title="如何优雅的解决这个问题呢？"></a>如何优雅的解决这个问题呢？</h2><p>Stack Overflow上有同学提出了类似的问题</p><blockquote><p><a href="https://stackoverflow.com/questions/26817420/why-i-cant-save-wkwebview-to-nsuserdefaults-standarduserdefaults/" target="_blank" rel="noopener">Why I can’t save WKWebView to [NSUserDefaults standardUserDefaults]?</a></p></blockquote><p>Firefox for iOS的工程师给出了他们的<a href="https://stackoverflow.com/questions/26817420/why-i-cant-save-wkwebview-to-nsuserdefaults-standarduserdefaults/31538352#31538352" target="_blank" rel="noopener">解决思路</a>：</p><blockquote><p>There is no easy answer here. The WKWebView cannot be archived and it does also not participate in UI state preservation/restoration. You already discovered this.</p></blockquote><blockquote><p>For Firefox for iOS we took a different route to work around these limitations. This far from ideal but it does work.</p></blockquote><blockquote><p>When we restore a tab that has session info (previously visited pages) attached, we load a special html page from a local web server (running on localhost) that modifies the push state of the page and pushes previously visited URLs on the history stack.</p></blockquote><blockquote><p>Because these URLs need to be of same origin, we basically push urls like `<a href="http://localhost:1234/history/item?url=http://original.url.com" target="_blank" rel="noopener">http://localhost:1234/history/item?url=http://original.url.com</a></p></blockquote><blockquote><p>In our UI we translate this to display original.url.com. When the user goes back in history to load these, we intercept and instead of loading the page from localhost, we load the original page.</p></blockquote><blockquote><p>It is a big hack but that is all we have at this point.</p></blockquote><blockquote><p>See the source code at <a href="https://github.com/mozilla/firefox-ios" target="_blank" rel="noopener">https://github.com/mozilla/firefox-ios</a></p></blockquote><h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><ol><li>当app启动需要恢复浏览历史的时候，启动一个本地的Web server并且加载一个特定的本地页面</li><li>提取之前保存的所有url信息，构造本地url越过<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener">同源策略</a>限制，传递到特定本地页面中，该页面通过调用<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener"><code>pushState</code></a>来达到修改<code>backForwradList</code>的目的</li><li>当本地加载这些特殊<code>url</code>的时候，之前启动的本地server可以将其重定向到正确的<code>url</code></li></ol><h2 id="实现一下"><a href="#实现一下" class="headerlink" title="实现一下"></a>实现一下</h2><ol><li>首先<a href="https://github.com/mozilla-mobile/firefox-ios" target="_blank" rel="noopener">Firefox for iOS</a>是基于Swift的开源项目，我们可以在<a href="https://github.com/mozilla-mobile/firefox-ios/blob/master/LICENSE" target="_blank" rel="noopener"><strong>遵守开源协议</strong></a>的基础上参考/借鉴其具体实现。</li><li>下面的sample code从Firefox的repo中提取出来，用到了<a href="https://github.com/swisspol/GCDWebServer" target="_blank" rel="noopener"><code>GCDWebServer</code></a>和<a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener"><code>SwiftyJSON</code></a></li></ol><h3 id="SessionRestore-html"><a href="#SessionRestore-html" class="headerlink" title="SessionRestore.html"></a>SessionRestore.html</h3><p>文件来源: </p><p><a href="https://github.com/mozilla-mobile/firefox-ios/blob/v10.x/Client/Assets/SessionRestore.html" target="_blank" rel="noopener">https://github.com/mozilla-mobile/firefox-ios/blob/v10.x/Client/Assets/SessionRestore.html</a></p><p>code很少注释也写的很清楚，在我们通过<code>http://localhost:{port}/errors/restore?history={&quot;currentPage&quot;: -1, &quot;history&quot;: [&quot;http://1.com&quot;, &quot;http://2.com&quot;]}</code>加载这个页面的时候</p><ol><li>脚本会取出url中的history参数<code>{&quot;currentPage&quot;: -1, &quot;history&quot;: [&quot;http://1.com&quot;, &quot;http://2.com&quot;]}</code>，然后将url转换成local格式<code>{&quot;currentPage&quot;: -1, &quot;history&quot;: [&quot;/errors/error.html?url=http://1.com&quot;, &quot;/errors/error.html?url=http://2.com&quot;]}</code></li><li>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener"><code>pushState</code></a>达到修改<code>WKWebView</code>的<code>backForwardList</code>的效果</li><li>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener"><code>go</code></a>跳转到<code>backForwardList</code>中某个位置</li><li>最后通知native端刷新页面以显示当前页面</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This Source Code Form is subject to the terms of the Mozilla Public</span></span><br><span class="line"><span class="comment">- License, v. 2.0. If a copy of the MPL was not distributed with this</span></span><br><span class="line"><span class="comment">- file, You can obtain one at http://mozilla.org/MPL/2.0/. --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"never"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        /**</span></span><br><span class="line"><span class="undefined">        * This file is responsible for restoring session history.</span></span><br><span class="line"><span class="undefined">        * It uses the DOM history API to push pages onto the back/forward stack. Since that API</span></span><br><span class="line"><span class="undefined">        * is bound by same origin restrictions, we're only able to push pages with the current origin</span></span><br><span class="line"><span class="undefined">        * (which is a page hosted on localhost). As a workaround, push all to-be-restored URLs as</span></span><br><span class="line"><span class="undefined">        * error pages so that they will redirect to the correct URLs when loaded.</span></span><br><span class="line"><span class="undefined">        */</span></span><br><span class="line"><span class="undefined">        (function () &#123;</span></span><br><span class="line"><span class="undefined">            function getRestoreURL(url) &#123;</span></span><br><span class="line"><span class="undefined">                // If the url already points to an error page just return the url as is</span></span><br><span class="line"><span class="undefined">                if (url.indexOf(document.location.origin + '/errors/error.html') === 0) &#123;</span></span><br><span class="line"><span class="undefined">                    return url;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                // Otherwise, push an error page to trigger a redirect when loaded.</span></span><br><span class="line"><span class="undefined">                return '/errors/error.html?url=' + escape(url);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            var index = document.location.href.search("history");</span></span><br><span class="line"><span class="undefined">            // Pull the session out of the history query argument.</span></span><br><span class="line"><span class="undefined">            // The session is a JSON-stringified array of all URLs to restore for this tab, plus the last active index.</span></span><br><span class="line"><span class="undefined">            var sessionRestoreComponents = JSON.parse(unescape(document.location.href.substring(index + "history=".length)));</span></span><br><span class="line"><span class="undefined">            var urlList = sessionRestoreComponents['history'];</span></span><br><span class="line"><span class="undefined">            var currentPage = sessionRestoreComponents['currentPage'];</span></span><br><span class="line"><span class="undefined">            // First, replace the session restore page (this page) with the first URL to be restored.</span></span><br><span class="line"><span class="undefined">            history.replaceState(&#123;&#125;, "", getRestoreURL(urlList[0]));</span></span><br><span class="line"><span class="undefined">            // Then push the remaining pages to be restored.</span></span><br><span class="line"><span class="undefined">            for (var i = 1; i &lt; urlList.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">                history.pushState(&#123;&#125;, '', getRestoreURL(urlList[i]));</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            // We'll end up at the last page pushed, so set the selected index to the current index in the session history.</span></span><br><span class="line"><span class="undefined">            history.go(currentPage);</span></span><br><span class="line"><span class="undefined">            // Finally, reload the page to trigger the error redirection, which will load the actual URL.</span></span><br><span class="line"><span class="undefined">            // For some reason (maybe a WebKit bug?), document.location still points to SessionRestore.html at this point,</span></span><br><span class="line"><span class="undefined">            // so wait until the next tick when the location points to the correct index and URL.</span></span><br><span class="line"><span class="undefined">            setTimeout(function () &#123;</span></span><br><span class="line"><span class="undefined">                webkit.messageHandlers.sessionRestoreMessageHandler.postMessage(&#123; type: "reload" &#125;);</span></span><br><span class="line"><span class="undefined">            &#125;, 0);</span></span><br><span class="line"><span class="undefined">        &#125;)();</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="WebServer"><a href="#WebServer" class="headerlink" title="WebServer"></a>WebServer</h3><p>文件来源: </p><p><a href="https://github.com/mozilla-mobile/firefox-ios/blob/v10.x/Client/Application/WebServer.swift" target="_blank" rel="noopener">https://github.com/mozilla-mobile/firefox-ios/blob/v10.x/Client/Application/WebServer.swift</a></p><p>这里的实现比较简单，利用<code>GCDWebServer</code>这个库，起了一个本地server并暴露了路由方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> instance = <span class="type">WebServer</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> server = <span class="type">GCDWebServer</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://localhost:\(self.server.port)"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !<span class="keyword">self</span>.server.isRunning <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">self</span>.server.start(</span><br><span class="line">            options: [</span><br><span class="line">                <span class="type">GCDWebServerOption_Port</span>: <span class="number">6571</span>,</span><br><span class="line">                <span class="type">GCDWebServerOption_BindToLocalhost</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="type">GCDWebServerOption_AutomaticallySuspendInBackground</span>: <span class="literal">true</span></span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Convenience method to register a dynamic handler. Will be mounted at $base/$module/$resource</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">registerHandlerForMethod</span><span class="params">(<span class="number">_</span> method: String, module: String, resource: String, handler: @escaping <span class="params">(<span class="number">_</span> request: GCDWebServerRequest?)</span></span></span> -&gt; <span class="type">GCDWebServerResponse</span>?) &#123;</span><br><span class="line">        <span class="comment">// Prevent serving content if the requested host isn't a whitelisted local host.</span></span><br><span class="line">        <span class="keyword">let</span> wrappedHandler = &#123;(request: <span class="type">GCDWebServerRequest</span>?) -&gt; <span class="type">GCDWebServerResponse</span>? <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> request = request, request.url.isLocal <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">GCDWebServerResponse</span>(statusCode: <span class="number">403</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> handler(request)</span><br><span class="line">        &#125;</span><br><span class="line">        server.addHandler(forMethod: method, path: <span class="string">"/\(module)/\(resource)"</span>, request: <span class="type">GCDWebServerRequest</span>.<span class="keyword">self</span>, processBlock: wrappedHandler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SessionRestoreHandler"><a href="#SessionRestoreHandler" class="headerlink" title="SessionRestoreHandler"></a>SessionRestoreHandler</h3><p> 文件来源:</p><p> <a href="https://github.com/mozilla-mobile/firefox-ios/blob/8a33d5d19852d521ab422c31015fc6b3e001378c/Client/Frontend/Browser/SessionRestoreHandler.swift" target="_blank" rel="noopener">https://github.com/mozilla-mobile/firefox-ios/blob/8a33d5d19852d521ab422c31015fc6b3e001378c/Client/Frontend/Browser/SessionRestoreHandler.swift</a></p><p> 这个文件主要是用来注册两个路由</p><ul><li><code>/errors/restore?history=...</code>是app刚启动恢复浏览记录的时候加载的<code>url</code></li><li><code>/errors/error.html?url=...</code>是<code>SessionRestore.html</code>最后加载的<code>url</code>，这里我们会将实际的<code>url</code>取出并加载</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionRestoreHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(<span class="number">_</span> webServer: WebServer)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Register the handler that accepts /errors/restore?history=... requests.</span></span><br><span class="line">        webServer.registerHandlerForMethod(<span class="string">"GET"</span>, module: <span class="string">"errors"</span>, resource: <span class="string">"restore"</span>) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> sessionRestorePath = <span class="type">Bundle</span>.main.path(forResource: <span class="string">"SessionRestore"</span>, ofType: <span class="string">"html"</span>), <span class="keyword">let</span> sessionRestoreString = <span class="keyword">try</span>? <span class="type">String</span>(contentsOfFile: sessionRestorePath) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">GCDWebServerResponse</span>(statusCode: <span class="number">404</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">GCDWebServerDataResponse</span>(html: sessionRestoreString)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register the handler that accepts /errors/error.html?url=... requests.</span></span><br><span class="line">        webServer.registerHandlerForMethod(<span class="string">"GET"</span>, module: <span class="string">"errors"</span>, resource: <span class="string">"error.html"</span>) &#123; request <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> url = request?.url.originalURLFromErrorURL <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">GCDWebServerResponse</span>(statusCode: <span class="number">404</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">GCDWebServerDataResponse</span>(redirect: url, permanent: <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><p>文件来源: </p><p><a href="https://github.com/mozilla-mobile/firefox-ios/blob/master/Client/Frontend/Browser/Tab.swift" target="_blank" rel="noopener">https://github.com/mozilla-mobile/firefox-ios/blob/master/Client/Frontend/Browser/Tab.swift</a></p><p>逻辑很清楚，将之前保存的<code>url</code>和<code>currentPage</code>信息拼好传到<code>url</code>里然后加载</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonDict: [<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">    <span class="string">"history"</span>: backforwardHistory.urls.compactMap &#123; $<span class="number">0</span>.absoluteString &#125; <span class="keyword">as</span> <span class="type">AnyObject</span>,</span><br><span class="line">    <span class="string">"currentPage"</span>: -backforwardHistory.currentIndexButLast <span class="keyword">as</span> <span class="type">AnyObject</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> json = <span class="type">JSON</span>(jsonDict).rawString(.utf8, options: [])?.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> restoreUrl = <span class="type">URL</span>(string: <span class="string">"\(WebServer.instance.base)/errors/restore?history=\(json)"</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.webView.load(<span class="type">URLRequest</span>(url: restoreUrl))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Info-plist"><a href="#Info-plist" class="headerlink" title="Info.plist"></a>Info.plist</h3><p>因为我们需要加载localhost，所以需要在<code>Info.plist</code>里面添加如下key-value.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsLocalNetworking<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>WKWebView</code>的<code>backForwardList</code>是只读的，这一点限制了我们对浏览历史进行恢复操作</li><li>Firefox的做法通过HTML提供的<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener"><code>pushState</code></a>接口，绕过了这个限制，从另一个角度修改了<code>backForwardList</code></li><li>除了这个方法，或许（肯定）还会有其他的方法，我们之后再来讨论。</li></ol>]]></content>
    
    <summary type="html">
    
      本文对如何实现恢复WKWebView浏览历史进行了总结与探索，同时对Firefox的具体实现进行了分析。
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>不同WKWebView之间实现浏览状态隔离</title>
    <link href="http://yoursite.com/2019/01/12/Session-isolation/"/>
    <id>http://yoursite.com/2019/01/12/Session-isolation/</id>
    <published>2019-01-12T06:35:23.000Z</published>
    <updated>2019-01-23T10:23:23.512Z</updated>
    
    <content type="html"><![CDATA[<p>项目中用到了<code>WKWebView</code>来渲染网页，有一个需求是在不同的账号下希望实现浏览状态隔离，如何实现呢？</p><h2 id="Sample-app"><a href="#Sample-app" class="headerlink" title="Sample app"></a>Sample app</h2><p>下图是我们用来测试的sample app, 两个tab分别有两个不同的<code>WKWebView</code>实例，每次用户切换tab的时候，对应的tab会刷新对<code>https://login.live.com</code>这个地址的访问。</p><img src="/2019/01/12/Session-isolation/sample-app.png"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>默认状态下，不同的<code>WKWebView</code>实例是不会共享浏览状态的，因此我们可以在两个tab登录不同的账号，切换tab的时候对应的登录状态不会乱掉</li><li>但是如果我们在其中一个tab网页登录的时候选择<code>Keep me signed in</code>，奇怪的事情发生了，当切换到另一个tab的时候，发现另一个tab竟然也处于登录的状态<img src="/2019/01/12/Session-isolation/keep-me-signed-in.png"></li></ol><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li>勾选<code>Keep me signed in</code>的时候发生了什么？<br>登录状态的保持需要客户端保存cookie，而我们知道cookie是分<a href="https://en.wikipedia.org/wiki/HTTP_cookie#Session_cookie" target="_blank" rel="noopener">session cookie</a>和<a href="https://en.wikipedia.org/wiki/HTTP_cookie#Persistent_cookie" target="_blank" rel="noopener">persistent cookie</a>的，两者的区别在<code>WKWebView</code>的体现就是，前者会在<code>WKWebView</code>实例消失的时候随之消失，而后者会保存在文件系统中。当用户勾选<code>Keep me signed in</code>的时候，网页会写入某些<code>persistent cookie</code>，这样当app下次启动初始化<code>WKWebView</code>的时候，网页就能读取到这些内容保持用户的登录状态。<br>下图是app的文件系统，我们发现当勾选了<code>Keep me signed in</code>，但是人为删除<code>Cookies</code>文件时，网页的登录状态会丢失，这样也进一步验证了我们的想法（也可以打开<code>Cookies</code>文件查看内容）</li></ol><img src="/2019/01/12/Session-isolation/cookies-in-file-system.png"><ol start="2"><li><p>为什么默认状态下，<code>WKWebView</code>不会共享浏览状态？<br>默认状态下，不同的<code>WKWebView</code>拥有不同的<a href="https://developer.apple.com/documentation/webkit/wkwebviewconfiguration/1395659-processpool" target="_blank" rel="noopener">processPool</a>, 因此浏览状态相互之间是不会共享的。</p></li><li><p>为什么选择<code>Keep me signed in</code>的时候浏览状态会共享？</p></li></ol><ul><li><p>首先要介绍<a href="https://developer.apple.com/documentation/webkit/wkwebsitedatastore" target="_blank" rel="noopener">WKWebsiteDataStore</a>的概念</p><blockquote><p>A WKWebsiteDataStore object represents various types of data used by a chosen website. Data types include <strong>cookies</strong>, disk and memory caches, and persistent data such as WebSQL, IndexedDB databases, and local storage.</p></blockquote><p>iOS SDK提供了两种<code>WKWebsiteDataStore</code>, <a href="https://developer.apple.com/documentation/webkit/wkwebsitedatastore/1532937-default" target="_blank" rel="noopener">WKWebsiteDataStore.default()</a>会返回默认的, persistent dataStore，而<a href="https://developer.apple.com/documentation/webkit/wkwebsitedatastore/1532934-nonpersistent" target="_blank" rel="noopener">WKWebsiteDataStore.nonPersistent()</a>会创建一个non-persistent dataStore并返回（苹果的<a href="https://developer.apple.com/documentation/webkit/wkwebviewconfiguration/1395661-websitedatastore" target="_blank" rel="noopener">文档</a>也介绍了，这种dataStore经常被用来实现无痕浏览）。</p><blockquote><p>If a web view is associated with a nonpersistent data store, no data is written to the file system. This property implements <strong>private browsing</strong> in a web view.</p></blockquote></li><li><p>默认状态下，<code>WKWebView</code>的<a href="https://developer.apple.com/documentation/webkit/wkwebviewconfiguration/1395661-websitedatastore" target="_blank" rel="noopener">websiteDataStore</a>是default版本的，也就是支持persistent cookie的dataStore</p></li><li>因此单纯的使用不同的<code>WKProcessPool</code>（默认行为），并不能保证浏览状态的隔离；由于默认状态下使用了相同的支持persistent cookie的<code>WKWebsiteDataStore.default()</code>，网页需要persistent的cookie会共享。</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>从上面的分析来看，解决方法看起来很直接，我们可以让不同的<code>WKWebView</code>持有不同的<code>WKWebsiteDataStore.nonPersistent()</code>实例<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> webView: <span class="type">WKWebView</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> config = <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line">    config.websiteDataStore = <span class="type">WKWebsiteDataStore</span>.nonPersistent()</span><br><span class="line">    <span class="keyword">let</span> view = <span class="type">WKWebView</span>(frame: .zero, configuration: config)</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><p>我们发现无论是否勾选<code>Keep me signed in</code>，登录状态都不会共享，太好了！</p><h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><img src="/2019/01/12/Session-isolation/but.jpg"><p>当用户勾选了<code>Keep me signed in</code>，杀掉app之后，我们发现登录状态”竟然”丢失了！这样虽然我们实现了登录状态隔离，但是<code>Keep me signed in</code>这个选项变得无用，这可不是一个专业的工程师希望看到的。而我们也知道，这也是我们采用了上述方案之后expected结果，因为<code>WKWebsiteDataStore.nonPersistent()</code>本身就是不支持persistent cookie的。</p><p>我们看起来<a href="https://www.bilibili.com/video/av40176036" target="_blank" rel="noopener">进退维谷</a>（这是一个视频链接，请不要在公众场合打开 ;))</p><ul><li>要想实现登录状态隔离，必须使用不同的<code>WKWebsiteDataStore</code></li><li>只有<code>WKWebsiteDataStore.default()</code>才能保存persistent cookie</li><li>但是<code>WKWebsiteDataStore.default()</code>是一个类似单例的存在，我们无法创建不同的persistent <code>WKWebsiteDataStore</code></li></ul><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法+1"></a>解决方法+1</h2><p>于是我们开始尝试：</p><img src="/2019/01/12/Session-isolation/stackoverflow.jpg"><p>然后在面向StackOverflow编程无果之后，你终于意识到自己已经是有经验的工程师了，应该可以独立解决问题了，在苦思冥想之后，终于想到了下面的方法</p><ul><li><p>去看<a href="https://opensource.apple.com/release/ios-110.html" target="_blank" rel="noopener">Webkit</a>的源码，想办法使用私有的api</p><p>在浏览<code>_WKWebsiteDataStoreConfiguration.h</code>这个文件时，我们发现如下的定义</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;WebKit/WKFoundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if WK_API_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WK_CLASS_AVAILABLE</span>(macosx(<span class="built_in">WK_MAC_TBA</span>), ios(<span class="built_in">WK_IOS_TBA</span>))</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_WKWebsiteDataStoreConfiguration</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span>=_setWebStorageDirectory:) <span class="built_in">NSURL</span> *_webStorageDirectory;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span>=_setIndexedDBDatabaseDirectory:) <span class="built_in">NSURL</span> *_indexedDBDatabaseDirectory;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span>=_setWebSQLDatabaseDirectory:) <span class="built_in">NSURL</span> *_webSQLDatabaseDirectory;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span>=_setCookieStorageFile:) <span class="built_in">NSURL</span> *_cookieStorageFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>  于是理论上我们可以创建<code>WKWebsiteDataStoreConfiguration</code>之后，配置不同的<code>cookieStorageFile</code>路径，然后利用下面的private API，来创建不同的支持的persistent cookie的dataStore</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WKWebsiteDataStore</span> (<span class="title">WKPrivate</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)_allWebsiteDataTypesIncludingPrivate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)_initWithConfiguration:(_WKWebsiteDataStoreConfiguration *)configuration <span class="built_in">WK_API_AVAILABLE</span>(macosx(<span class="built_in">WK_MAC_TBA</span>), ios(<span class="built_in">WK_IOS_TBA</span>));</span><br></pre></td></tr></table></figure><p>  但是我们担心无法通过苹果的审核，同时这样做需要花更多的时间去看源码确保是可行的，作为一名有经验的工程师，我们认为这不是一条正路</p></li><li><p>终于，我们意识到，既然支持persistent cookie的本质就是把cookie保存到文件系统里，那我们能不能自己来实现呢？</p><p>对于我们的sample app，我们的方案如下:</p><ol><li>两个<code>WebView</code>实例分别使用<code>WKWebsiteDataStore.default()</code>和<code>WKWebsiteDataStore.nonPersistent()</code></li><li>对于使用<code>WKWebsiteDataStore.default()</code>的<code>WebView</code>实例，我们依靠其自身的cookie persistence机制</li><li>对于使用<code>WKWebsiteDataStore.nonPersistent()</code>的<code>WebView</code>实例<ul><li>在恰当的时机，读取<code>webView</code>的所有cookie并保存到文件里</li><li>在初始化该<code>webView</code>的时候，读取文件中的所有cookie并加载到<code>webView</code>中</li></ul></li></ol><p>简单明了的方案，当然我们的代码也应该体现出我们的水平。</p><ul><li>这里我们extend了<code>WKWebsiteDataStore</code>,暴露了<code>persistCookies</code>和<code>restoreCookies</code>两个方法，暴露了<code>cookieStorageFile</code>这个属性</li><li><p>sample app中使用了最简单的<code>NSKeyedArchiver</code>来实现数据持久化（要注意在操作大文件时archive/unarchive是耗时的操作，如果可能尽量放到其他线程去做；但同时cookie的读写又必须在主线程上进行）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WKWebsiteDataStoreAssociatedKeys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> cookieStorageFile: <span class="type">UInt8</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WKWebsiteDataStore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieStorageFile: <span class="type">URL</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">WKWebsiteDataStoreAssociatedKeys</span>.cookieStorageFile) <span class="keyword">as</span>? <span class="type">URL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">WKWebsiteDataStoreAssociatedKeys</span>.cookieStorageFile, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">persistCookies</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !<span class="keyword">self</span>.isPersistent <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cookieStorageFilePath = <span class="keyword">self</span>.cookieStorageFile?.path <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.httpCookieStore.getAllCookies &#123; cookies <span class="keyword">in</span></span><br><span class="line">            <span class="type">NSKeyedArchiver</span>.archiveRootObject(cookies.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.isSessionOnly &#125;, toFile: cookieStorageFilePath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restoreCookies</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !<span class="keyword">self</span>.isPersistent <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cookieStorageFilePath = <span class="keyword">self</span>.cookieStorageFile?.path <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cookies = <span class="type">NSKeyedUnarchiver</span>.unarchiveObject(withFile: cookieStorageFilePath) <span class="keyword">as</span>? [<span class="type">HTTPCookie</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cookies.forEach &#123; cookie <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.httpCookieStore.setCookie(cookie, completionHandler: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在使用的时候，只要给<code>webSiteDataStore</code>设置<code>cookieStorageFile</code>并且在合适的时机调用<code>restoreCookies</code>和<code>persistCookies</code>即可。</p></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>于是，我们设计的这套方案，”完美”(作为一名有经验的工程师，我们知道后续还会有各种各样奇奇怪怪的问题/需求出现）的解决了</p><ul><li>不同的<code>WebView</code>之间浏览状态隔离</li><li>Persistent cookie能够正常工作</li><li>该方案可以简单的推广到N(N&gt;2)个<code>WebView</code>的情况，只需设置不同的<code>WKWebsiteDataStore.nonPersistent()</code>和<code>cookieStorageFile</code>即可</li></ul><p>终于，我们有时间感慨，今晚的月色真美啊！</p><img src="/2019/01/12/Session-isolation/happy.jpg">]]></content>
    
    <summary type="html">
    
      本文总结了在实现不同WKWebView实例之间浏览状态隔离过程中所踩的一些坑，同时给出了一套可行的解决方案。
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly</title>
    <link href="http://yoursite.com/2019/01/09/WebAssembly/"/>
    <id>http://yoursite.com/2019/01/09/WebAssembly/</id>
    <published>2019-01-09T07:12:44.000Z</published>
    <updated>2019-01-09T09:08:39.289Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 <a href="https://webassembly.org" target="_blank" rel="noopener">WebAssembly</a> 相关的事情，边做边总结吧</p><h2 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a><a href="https://kripken.github.io/emscripten-site/docs/site/glossary.html" target="_blank" rel="noopener">Glossary</a></h2><ul><li><a href="https://webassembly.org" target="_blank" rel="noopener">WebAssembly</a>: WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable target for compilation of high-level languages like C/C++/Rust, enabling deployment on the web for client and server applications.</li><li><a href="https://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html" target="_blank" rel="noopener">emscripten</a>: Emscripten is an Open Source LLVM to JavaScript compiler.</li><li><a href="https://kripken.github.io/emscripten-site/docs/tools_reference/emsdk.html#emsdk" target="_blank" rel="noopener">emsdk</a>: The Emscripten SDK (emsdk) is used to perform all SDK maintenance and can install, update, add, remove and activate SDKs and tools.</li><li><a href="https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html#emccdoc" target="_blank" rel="noopener">emcc</a>: The Emscripten Compiler Frontend (emcc). Emscripten’s drop-in replacement for a compiler like <code>gcc</code>.</li></ul><p>我做的事情是希望在Web环境中用到C++的一个库，所以套用上面的术语，就是我会用利用<code>emsdk</code>提供的环境，使用<code>emcc</code>将<code>C++</code>编译成<code>WebAssembly</code>格式, 然后在<code>Web</code>环境中使用.</p><img src="/2019/01/09/WebAssembly/EmscriptenToolchain.png"><blockquote><p>image source: <a href="https://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html" target="_blank" rel="noopener">https://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html</a></p></blockquote><h2 id="Browser-compatibility"><a href="#Browser-compatibility" class="headerlink" title="Browser compatibility"></a>Browser compatibility</h2><p>实践中我们比较关心的关于Thread的兼容性：</p><table><thead><tr><th>Tables</th><th>Available version</th><th>Conditions</th></tr></thead><tbody><tr><td>Google chrome</td><td>Chrome 70</td><td>Turn on experimental “WebAssembly threads support” flag</td></tr><tr><td>Mozilla firefox</td><td>Firefox nightly channel</td><td>Turn on “javascript.options.shared_memory” flag</td></tr></tbody></table><blockquote><p>Emscripten has support for multithreading using the new <strong>SharedArrayBuffer</strong> capability in browsers. Note that SharedArrayBuffer was <strong>disabled</strong> by default in all major browsers on 5 January, 2018 in response to <a href="https://meltdownattack.com" target="_blank" rel="noopener">Spectre</a>. <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=821270" target="_blank" rel="noopener">Chrome re-enabled it in v67</a> on platforms where its site-isolation feature is enabled to protect against Spectre-style vulnerabilities.</p></blockquote><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the emsdk repo</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/juj/emsdk.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enter that directory</span></span><br><span class="line"><span class="built_in">cd</span> emsdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># Activate PATH and other environment variables in the current terminal</span></span><br><span class="line"><span class="built_in">source</span> ./emsdk_env.sh</span><br></pre></td></tr></table></figure><p>Sample JavaScript-C++ interoperability code</p><ul><li><p>hello.cc</p><pre><code>#include &lt;pthread.h&gt;#include &lt;iostream&gt;extern &quot;C&quot;{    extern int js_func();    void* test(void*)    {        std::cout &lt;&lt; &quot;Background thread&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; js_func() &lt;&lt; std::endl;        return NULL;    }    void cpp_func()    {        pthread_t t;        pthread_create(&amp;t, NULL, &amp;test, NULL);        std::cout &lt;&lt; &quot;Main thread&quot; &lt;&lt; std::endl;    }}</code></pre></li><li><p>hello.js</p><pre><code>Module.onRuntimeInitialized = () =&gt; {    const cpp_func = Module.cwrap(&apos;cpp_func&apos;, null);    cpp_func();};</code></pre></li><li><p>hello.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script src=&quot;wasm.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;hello.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>export.js</p><pre><code>mergeInto(LibraryManager.library, {    js_func: function () {        return 10;    },});</code></pre></li><li><p>Build</p><pre><code>emcc hello.cc -o wasm.js -s EXPORTED_FUNCTIONS=&apos;[&quot;_cpp_func&quot;]&apos; -s EXTRA_EXPORTED_RUNTIME_METHODS=&apos;[&quot;cwrap&quot;]&apos; --js-library export.js -std=c++14 -s USE_PTHREADS=1 -s PTHREAD_POOL_SIZE=2 -g4</code></pre><p>Build完之后会生成<code>wasm.js</code>和<code>wasm.wasm</code>，其中<code>wasm.js</code>已经在<code>hello.html</code>中被引用，<code>wasm.wasm</code>会在<code>wasm.js</code>中被<code>fetch</code>, <code>compile</code> and <code>instantiate</code></p></li><li><p>直接打开<code>hello.html</code>看到输出</p><img src="/2019/01/09/WebAssembly/hello-output.png"></li></ul><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>目前踩到的一些<strong>比较棘手</strong>的坑（嗯小坑不断）</p><ol><li><a href="https://github.com/kripken/emscripten/issues/7812" target="_blank" rel="noopener">Calling derived JavaScript object inside another thread causes binding error</a><ul><li>这个是我遇到的一个比较严重的问题，简单来说就是在<code>embind</code>和<code>webidl</code>的环境下，JavaScript能够实现C++中定义的interface，但却无法在C++的multi-thread环境中被调用</li><li>错误信息是JavaScript的Web workder环境无法识别<code>Module</code>中JavaScript中实现的Object</li><li>debug过程中发现，multi-thread环境下生成的<code>pthread-main.js</code>(worker)中, <code>Module</code>并不包含JavaScript实现的Object，具体的重现过程可以参考我在上面链接中的提出的issue</li><li>绕过这个坑的方法：目前使用纯C的接口可以绕过这个，当然不可避免的损失了C++ class的一些便利性</li></ul></li><li><a href="https://github.com/kripken/emscripten/issues/6362#issuecomment-380577403" target="_blank" rel="noopener">embind not maintained</a>?</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://kripken.github.io/emscripten-site/docs/site/glossary.html" target="_blank" rel="noopener">Glossary</a></li><li><a href="https://github.com/kripken/emscripten/issues" target="_blank" rel="noopener">Emscripten issues</a></li><li><a href="http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/WebIDL-Binder.html" target="_blank" rel="noopener">WebIDL</a></li><li><a href="http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html" target="_blank" rel="noopener">Embind</a></li><li>Test suite: <ul><li><a href="https://github.com/kripken/emscripten/tree/master/tests/embind" target="_blank" rel="noopener">Embind</a></li><li><a href="https://github.com/kripken/emscripten/tree/master/tests/webidl" target="_blank" rel="noopener">Webidl</a></li></ul></li><li><a href="https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a" target="_blank" rel="noopener">WebAssembly + Web worker</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">WebWorker</a></li><li>Big projects:<ul><li><a href="https://github.com/kripken/box2d.js" target="_blank" rel="noopener">Box2d.js</a> (webidl)</li><li><a href="https://github.com/ucisysarch/opencvjs" target="_blank" rel="noopener">OpenCV.js</a> (embind)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      本文作为WebAssembly的入门文章，总结了WebAssembly的相关概念，同时列出了调研过程中踩的一些坑
    
    </summary>
    
      <category term="WebAssembly" scheme="http://yoursite.com/categories/WebAssembly/"/>
    
    
      <category term="WebAssembly" scheme="http://yoursite.com/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>App thinning checklist</title>
    <link href="http://yoursite.com/2019/01/09/App-thinning-checklist/"/>
    <id>http://yoursite.com/2019/01/09/App-thinning-checklist/</id>
    <published>2019-01-09T05:01:21.000Z</published>
    <updated>2019-01-09T09:08:46.931Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间对<a href="https://itunes.apple.com/us/app/microsoft-edge/id1288723196" target="_blank" rel="noopener">Microsoft Edge for iOS</a>进行了瘦身，总结如下。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ol><li>关于Edge for iOS的一些背景<ul><li>主要语言是Swift, 所以不可避免的有Swift的8MB问题</li><li>项目使用Cocoapods管理依赖，倾向于使用静态库而非动态库</li><li>因为项目原因有一些必要依赖无法避免</li></ul></li><li>本文列举了在进行包优化的过程中所使用的一些方法/工具，其中效果显著的步骤<strong>加粗</strong>显示 （主要是清除多余文件/资源，动态库转静态库)</li><li>原文以英文内部邮件的形式发出，这里将原文脱密后附录如下</li></ol><h2 id="Why-app-size-matters"><a href="#Why-app-size-matters" class="headerlink" title="Why app size matters?"></a>Why app size matters?</h2><ol><li>Apple App store cellular download limit is 150 MB, which means app with compressed size over that limit can only be downloaded in WIFI environment</li><li>Data from Google play, for every 6 MB increase to app size, we see a decrease in the install conversion rate of 1%: <a href="https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2" target="_blank" rel="noopener">https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2</a></li></ol><h2 id="What-we-have-done-to-reduce-app-size"><a href="#What-we-have-done-to-reduce-app-size" class="headerlink" title="What we have done to reduce app size?"></a>What we have done to reduce app size?</h2><h3 id="Measure-app-size"><a href="#Measure-app-size" class="headerlink" title="Measure app size"></a>Measure app size</h3><ol><li>There’re two types of app size<ul><li>Download size: This is the compressed size of the app downloaded over the air. This is also what we’re trying to optimize</li><li>Install size: This is the amount of disk space the app will take up on the customer’s device. This is also what user sees on App store</li></ul></li></ol><img src="/2019/01/09/App-thinning-checklist/type-of-size.png"><blockquote><p>image source: <a href="https://stackoverflow.com/questions/35504571/is-ios-app-store-over-the-air-download-limit-based-on-download-size-or-instal" target="_blank" rel="noopener">https://stackoverflow.com/questions/35504571/is-ios-app-store-over-the-air-download-limit-based-on-download-size-or-instal</a></p></blockquote><ol start="2"><li><p>Inspect ipa files to examine the compressed size of each item in the .ipa file<br> <code>unzip -lv {app}.ipa</code></p><img src="/2019/01/09/App-thinning-checklist/unzip-ipa.png"><blockquote><p>image source: <a href="https://stackoverflow.com/questions/52422675/how-to-extract-contents-from-a-ipa-file" target="_blank" rel="noopener">https://stackoverflow.com/questions/52422675/how-to-extract-contents-from-a-ipa-file</a></p></blockquote></li><li><p><a href="https://github.com/kobe1941/shell" target="_blank" rel="noopener">Leverage LinkMap</a> to analyze the composition of main executable file</p></li></ol><img src="/2019/01/09/App-thinning-checklist/link-map.png">    <blockquote><p>image source: <a href="https://github.com/kobe1941/shell" target="_blank" rel="noopener">https://github.com/kobe1941/shell</a></p></blockquote><h3 id="Monitor-daily-build-size-change"><a href="#Monitor-daily-build-size-change" class="headerlink" title="Monitor daily build size change"></a>Monitor daily build size change</h3><p>We have integrated our package size report into our CI and it will auto generates report and mail alert</p><img src="/2019/01/09/App-thinning-checklist/package-size-report.png"><img src="/2019/01/09/App-thinning-checklist/package-size-report2.png"><h3 id="Analyze-code"><a href="#Analyze-code" class="headerlink" title="Analyze code"></a>Analyze code</h3><ol><li>Ensure Xcode build setting is correctly configured<ul><li>Optimization Level: Fastest, Smallest</li><li>Deployment Postprocessing: Yes</li><li>Strip linked Product: Yes</li><li>Symbols Hidden by default: Yes</li><li>Make Strings Read-only: Yes</li></ul></li><li><strong><a href="https://github.com/tsabend/fus" target="_blank" rel="noopener">Find and remove unused class</a></strong></li><li><strong><a href="https://medium.com/@gabriel_lewis/how-to-easily-find-unused-swift-code-in-xcode-159631961acf" target="_blank" rel="noopener">Find and remove unused code</a></strong></li></ol><h3 id="Analyze-assets"><a href="#Analyze-assets" class="headerlink" title="Analyze assets"></a>Analyze assets</h3><ol><li><strong><a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">Find and remove unused assets</a></strong></li><li><a href="https://github.com/adrianlopezroche/fdupes" target="_blank" rel="noopener">Find and remove duplicate files</a></li><li><strong>Remove extra fonts</strong></li><li><strong>Move on-demand resources to cloud</strong></li><li>Compress resources: <a href="https://imageoptim.com/mac" target="_blank" rel="noopener">Image</a>, <a href="https://ffmpeg.org" target="_blank" rel="noopener">Video/Audio</a></li></ol><h3 id="Analyze-dependencies"><a href="#Analyze-dependencies" class="headerlink" title="Analyze dependencies"></a>Analyze dependencies</h3><ol><li><strong><a href="https://recoursive.com/2018/06/06/static_libraries_cocoapods/" target="_blank" rel="noopener">Move Cocoapods dependencies from dynamic framework to static libraries</a></strong></li><li>Ensure dependencies are correctly built for release mode and resources compressed</li><li>Remove unneeded dependencies</li></ol><h2 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next?"></a>What’s next?</h2><p>There’re some potential optimization methods which need more efforts, we’re actively evaluating their feasibilities</p><ol><li>Use 8-bit PNG instead of 32-bit PNG</li><li>Replace small images with inline code</li><li>Compress JavaScript/html</li><li>Remove duplicate strings</li><li>Turn off C++/Objective-C exception support in Xcode</li></ol>]]></content>
    
    <summary type="html">
    
      本文总结了对Microsoft Edge for iOS进行了瘦身过程中所用到的方法/工具
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Performance" scheme="http://yoursite.com/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>Build and Install Hadoop 2.7.2 on Windows</title>
    <link href="http://yoursite.com/2016/02/17/Build-and-Install-Hadoop-2-7-2-on-Windows/"/>
    <id>http://yoursite.com/2016/02/17/Build-and-Install-Hadoop-2-7-2-on-Windows/</id>
    <published>2016-02-17T05:27:20.000Z</published>
    <updated>2019-01-09T08:59:24.263Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚在Windows10 + Visual Studio 2015 环境下配置了Hadoop Single Node Cluster,下面是主要的步骤.</p><h2 id="Build-Hadoop-Core"><a href="#Build-Hadoop-Core" class="headerlink" title="Build Hadoop Core"></a>Build Hadoop Core</h2><p>这部分主要参照<a href="http://kplitzkahran.blogspot.co.uk/2015/08/hadoop-271-for-windows-10-binary-build.html" target="_blank" rel="noopener">Hadoop 2.7.1 for Windows 10 binary build with Visual Studio 2015 (unofficial)</a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>D盘下新建目录D:\Hadoop 用来存放所有的Hadoop配置相关文件</p><h3 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h3><p>下载地址: <a href="http://download.oracle.com/otn-pub/java/jdk/8u73-b02/jdk-8u73-windows-x64.exe" target="_blank" rel="noopener">Java SE Development Kit 8u73 Windows x64</a><br>安装地址: D:\Hadoop\jdk1.8.0_73<br>将环境变量 JAVA_HOME 设置为jdk的位置 D:\Hadoop\jdk1.8.0_73</p><h3 id="Getting-Hadoop-sources"><a href="#Getting-Hadoop-sources" class="headerlink" title="Getting Hadoop sources"></a>Getting Hadoop sources</h3><p>下载地址: <a href="http://mirrors.ibiblio.org/apache/hadoop/common/current/hadoop-2.7.2-src.tar.gz" target="_blank" rel="noopener">hadoop-2.7.2-src.tar.gz</a><br>解压地址: D:\Hadoop\hadoop-2.7.2-src</p><h3 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h3><p>打开 D:\Hadoop\hadoop-2.7.2-src\BUILDING.txt ,里面列出了其他的Requirements:</p><ul><li>Maven 3.0 or later</li><li>ProtocolBuffer <strong>2.5.0</strong></li><li>CMake 2.6 or newer</li><li>zlib headers </li><li>Unix command-line tools from GnuWin32: sh, mkdir, rm, cp, tar, gzip. These tools must be present on your PATH.</li></ul><h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><p>下载地址: <a href="http://ftp.tsukuba.wide.ad.jp/software/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz" target="_blank" rel="noopener">apache-maven-3.3.9-bin.tar.gz</a><br>解压地址: D:\Hadoop\apache-maven-3.3.9<br>将 D:\Hadoop\apache-maven-3.3.9\bin 添加到PATH环境变量中</p><h4 id="ProtocolBuffer-2-5-0"><a href="#ProtocolBuffer-2-5-0" class="headerlink" title="ProtocolBuffer 2.5.0"></a>ProtocolBuffer 2.5.0</h4><p>下载地址: <a href="https://github.com/google/protobuf/releases/download/v2.5.0/protoc-2.5.0-win32.zip" target="_blank" rel="noopener">protocol-2.5.0-win32.zip</a><br>解压地址: D:\Hadoop\protoc-2.5.0-win32<br>将 D:\Hadoop\protoc-2.5.0-win32 添加到PATH环境变量中</p><h4 id="CMake-3-4-3"><a href="#CMake-3-4-3" class="headerlink" title="CMake 3.4.3"></a>CMake 3.4.3</h4><p>下载地址: <a href="https://cmake.org/files/v3.5/cmake-3.5.0-rc2-win32-x86.msi" target="_blank" rel="noopener">cmake-3.5.0-rc2-win32-x86.msi</a><br>安装时记得勾选添加到PATH环境变量<br><img src="/2016/02/17/Build-and-Install-Hadoop-2-7-2-on-Windows/CMake.png"></p><h4 id="zlib-headers"><a href="#zlib-headers" class="headerlink" title="zlib headers"></a>zlib headers</h4><p>下载地址: <a href="http://zlib.net/zlib128-dll.zip" target="_blank" rel="noopener">zlib128-dll.zip</a><br>解压地址: D:\Hadoop\zlib128-dll<br>在环境变量中添加ZLIB_HOME,值为D:\Hadoop\zlib128-dll\include</p><h4 id="Unix-command-line-tools-from"><a href="#Unix-command-line-tools-from" class="headerlink" title="Unix command-line tools from"></a>Unix command-line tools from</h4><p>根据BUILDING.txt,这个tool可以在安装git的时候顺带安装<br>下载地址: <a href="http://git-scm.com/download/win" target="_blank" rel="noopener">git-2.7.1</a><br><strong>安装的时候记得勾选 “Use Git and optional Unix tools from the Windows Command Prompt”</strong><br><img src="/2016/02/17/Build-and-Install-Hadoop-2-7-2-on-Windows/UnixCommandLineTools.png"></p><h3 id="配置MSBuild"><a href="#配置MSBuild" class="headerlink" title="配置MSBuild"></a>配置MSBuild</h3><p>将C:\Windows\Microsoft.NET\Framework64\v4.0.30319添加到PATH环境变量中</p><h3 id="更新VS-Project文件"><a href="#更新VS-Project文件" class="headerlink" title="更新VS Project文件"></a>更新VS Project文件</h3><p>用Visual Studio 2015打开下面两个solution,右键solution，选择Retarget Projects</p><ul><li>D:\Hadoop\hadoop-2.7.2-src\hadoop-common-project\hadoop-common\src\main\winutils\winutils.sln</li><li>D:\Hadoop\hadoop-2.7.2-src\hadoop-common-project\hadoop-common\src\main\native\native.sln<img src="/2016/02/17/Build-and-Install-Hadoop-2-7-2-on-Windows/RetargetProjects.png"></li></ul><h3 id="更新编译选项"><a href="#更新编译选项" class="headerlink" title="更新编译选项"></a>更新编译选项</h3><p>打开 D:\Hadoop\hadoop-2.7.2-src\hadoop-hdfs-project\hadoop-hdfs\pom.xml ,将下面这一行改为Visual Studio 2015的形式</p><p>修改前<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">condition</span> <span class="attr">property</span>=<span class="string">"generator"</span> <span class="attr">value</span>=<span class="string">"Visual Studio 10"</span> <span class="attr">else</span>=<span class="string">"Visual Studio 10 Win64"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>修改后<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">condition</span> <span class="attr">property</span>=<span class="string">"generator"</span> <span class="attr">value</span>=<span class="string">"Visual Studio 10"</span> <span class="attr">else</span>=<span class="string">"Visual Studio 14 2015 Win64"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="Build-Package-files"><a href="#Build-Package-files" class="headerlink" title="Build Package files"></a>Build Package files</h3><p>启动 Developer Command Prompt for VS2015<br><img src="/2016/02/17/Build-and-Install-Hadoop-2-7-2-on-Windows/DeveloperCommandPromptForVS2015.png"></p><p>在 D:\Hadoop\hadoop-2.7.2-src 下执行下面的命令<strong>设置 Platform environment variable</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set Platform=x64</span><br></pre></td></tr></table></figure><p>然后执行如下命令开始build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package -Pdist,native-win -DskipTests -Dtar</span><br></pre></td></tr></table></figure><p>build过程中如果出现 OutOfMemoryError,通过下面的命令 assign more memory,然后重新build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=128m</span><br></pre></td></tr></table></figure><p>如果出现jni.h找不到的错误，可以将下面三个文件复制到 C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\include 下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\Hadoop\jdk1.8.0_73\include\jni.h</span><br><span class="line">D:\Hadoop\jdk1.8.0_73\include\win32\jawt_md.h</span><br><span class="line">D:\Hadoop\jdk1.8.0_73\include\win32\jni_md.h</span><br></pre></td></tr></table></figure><h3 id="Copy-Package-files"><a href="#Copy-Package-files" class="headerlink" title="Copy Package files"></a>Copy Package files</h3><p>Build成功后，将 D:\Hadoop\hadoop-2.7.2-src\hadoop-dist\target\ 下的hadoop-2.7.2文件夹复制到 D:\Hadoop\hadoop-2.7.2</p><h2 id="Start-a-Single-Node-pseudo-distributed-Cluster"><a href="#Start-a-Single-Node-pseudo-distributed-Cluster" class="headerlink" title="Start a Single Node (pseudo-distributed) Cluster"></a>Start a Single Node (pseudo-distributed) Cluster</h2><p>接下来就可以参照<a href="http://wiki.apache.org/hadoop/Hadoop2OnWindows" target="_blank" rel="noopener">Build and Install Hadoop 2.x or newer on Windows</a>，配置Single Node Cluster，<strong>注意Command Prompt必须具有Admin权限</strong>，否则在执行yarn指令时会报错 “A required priviledge is not held by the client”</p><h2 id="在IntelliJ-IDEA中单机调试Hadoop程序"><a href="#在IntelliJ-IDEA中单机调试Hadoop程序" class="headerlink" title="在IntelliJ IDEA中单机调试Hadoop程序"></a>在IntelliJ IDEA中单机调试Hadoop程序</h2><p>这部分内容可以参照<a href="https://mrchief2015.wordpress.com/2015/02/09/compiling-and-debugging-hadoop-applications-with-intellij-idea-for-windows/" target="_blank" rel="noopener">HOW-TO: COMPILE AND DEBUG HADOOP APPLICATIONS WITH INTELLIJ IDEA IN WIDNOWS OS(64BIT)</a></p><p>注意的地方是<strong>WordCount例程中不要忘记下面这一行</strong>，否则Class not found</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.setJarByClass(WordCount.class);</span><br></pre></td></tr></table></figure><h2 id="Intellij-IDEA生成Jar包"><a href="#Intellij-IDEA生成Jar包" class="headerlink" title="Intellij IDEA生成Jar包"></a>Intellij IDEA生成Jar包</h2><p>这部分内容参照<a href="http://chenbiaolong.com/2015/03/26/%E6%90%AD%E5%BB%BAHadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">Intellij IDEA 搭建Hadoop开发环境</a></p><ul><li>选择菜单File-&gt;Project Structure，弹出Project Structure的设置对话框</li><li>选择左边的Artifacts后点击上方的“+”按钮 </li><li>在弹出的框中选择jar-&gt;from moduls with dependencies.. </li><li>选择要启动的类，然后 确定 </li><li>应用之后，对话框消失。在IDEA选择菜单Build-&gt;Build Artifacts,选择Build或者Rebuild后即可生成，生成的jar文件位于工程项目目录的out/artifacts下</li></ul><p>要注意的地方是<strong>修改args[0]和args[1]</strong>，将原先WordCount中的下面两行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure><p>改为</p><pre><code class="java">FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">2</span>]));</code></pre><p>原因可以参考这里<a href="http://stackoverflow.com/questions/4913212/org-apache-hadoop-mapred-filealreadyexistsexception" target="_blank" rel="noopener">org.apache.hadoop.mapred.FileAlreadyExistsException</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://wiki.apache.org/hadoop/Hadoop2OnWindows" target="_blank" rel="noopener">Build and Install Hadoop 2.x or newer on Windows</a></li><li><a href="http://kplitzkahran.blogspot.co.uk/2015/08/hadoop-271-for-windows-10-binary-build.html" target="_blank" rel="noopener">Hadoop 2.7.1 for Windows 10 binary build with Visual Studio 2015 (unofficial)</a></li><li><a href="https://cwiki.apache.org/confluence/display/MAVEN/OutOfMemoryError" target="_blank" rel="noopener">OutOfMemoryError</a></li><li><a href="https://mrchief2015.wordpress.com/2015/02/09/compiling-and-debugging-hadoop-applications-with-intellij-idea-for-windows/" target="_blank" rel="noopener">HOW-TO: COMPILE AND DEBUG HADOOP APPLICATIONS WITH INTELLIJ IDEA IN WIDNOWS OS(64BIT)</a></li><li><a href="http://chenbiaolong.com/2015/03/26/%E6%90%AD%E5%BB%BAHadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">Intellij IDEA 搭建Hadoop开发环境</a></li><li><a href="http://stackoverflow.com/questions/4913212/org-apache-hadoop-mapred-filealreadyexistsexception" target="_blank" rel="noopener">org.apache.hadoop.mapred.FileAlreadyExistsException</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文总结了在Windows10 + Visual Studio 2015 环境下配置了Hadoop Single Node Cluster的步骤
    
    </summary>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
</feed>
